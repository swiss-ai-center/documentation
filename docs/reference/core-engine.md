# Core engine

- [:material-account-group: Main author - HEIA-FR & HEIG-VD](https://www.hes-so.ch/swiss-ai-center/equipe)
- [:material-git: Code](https://github.com/swiss-ai-center/core-engine)
- [:material-kubernetes: Deployment configuration (backend)](https://github.com/swiss-ai-center/core-engine/tree/main/backend/kubernetes)
- [:material-kubernetes: Deployment configuration (frontend)](https://github.com/swiss-ai-center/core-engine/tree/main/frontend/kubernetes)
- [:material-test-tube: Staging (backend)](https://backend-core-engine-swiss-ai-center.kube.isc.heia-fr.ch)
- [:material-test-tube: Staging (frontend)](https://frontend-core-engine-swiss-ai-center.kube.isc.heia-fr.ch)
- [:material-factory: Production (backend - not available yet)](https://app.swiss-ai-center.ch/api)
- [:material-factory: Production (frontend - not available yet)](https://app.swiss-ai-center.ch)

The Core engine allows to create and manage pipelines of microservices.

The Core engine is split in two services:

- [Core engine Backend](#backend) - The API to register services and create
  pipelines
- [Core engine Frontend](#frontend) - The user interface to interact with the
  backend

## Backend

The Core engine Backend is built using Python 3.10, FastAPI, SQLModel and
Domain-driven design.

The API documentation is automatically generated by FastAPI using the OpenAPI
standard. A user-friendly interface provided by Swagger is available under the
`/docs` route, where the endpoints of the services are described.

### Diagrams

#### UML diagram

The models defined for each class is represented as follows:

![UML Diagram](../assets/screenshots/models_diagram.svg)

#### Sequence

A normal sequence of events when launching a request to a service is represented
as follows:

```mermaid
sequenceDiagram
    participant E as e - Core engine
    participant S as s - Service
    participant C as c - Client
    participant S3 as s3 - Storage
    S->>+E: POST(core-engine_url: str, service_json: ServiceCreate)
    E->>E: service: Service = Service.from_orm(service_json)
    E->>E: enable_service(service)
    E->>E: add_api_route(service.slug, handler)
    E-->>-S: return(200, service: ServiceRead)
    C->>+E: POST(/s.slug, data: UploadFile[])
    E->>+S3: file_keys = for file in data: storage_service.upload(file)
    S3-->>-E: return(200, file_key)
    E->>E: task = create_task(data_in: file_keys[])
    E->>E: service_task = new ServiceTask(s3_infos: str[], task)
    E->>+S: POST(s.url, service_task)
    S-->>-E: return(200, {status: Task added to the queue})
    E-->>-C: return(200, task: TaskReadWithServiceAndPipeline)
    S->>+S3: data = for key in service_task.task.data_in: get_file(service_task.s3_infos, key)
    S3-->>-S: return(200, stream)
    S->>S: result = process(data)
    S->>+S3: data_out = for res in result: upload_file(service_task.s3_infos, data_out)
    S3-->>-S: return(200, key)
    S->>S: task_update = jsonable_encoder(TaskUpdate({status: finished, task.data_out: data_out}))
    S->>+E: PATCH(core-engine_url: str, task_update)
    E-->-S: return(200, service: ServiceRead)
    C->>+E: GET(/tasks, task_id: str)
    E-->>-C: return(200, task: TaskReadWithServiceAndPipeline)
    C->>+S3: GET(task.data_out)
    S3-->>-C: return(200, stream)
```

### Environment variables

All environment variables are described in the
[`.env`](https://github.com/swiss-ai-center/core-engine/blob/main/core-engine/.env)
file.

The environment variables can be overwritten during the CI/CD pipeline described
in the
[`backend.yml`](https://github.com/swiss-ai-center/core-engine/blob/main/.github/workflows/backend.yml)
GitHub workflow file.

### Start the service locally with Python

In the `backend` directory, start the Core engine Backend with the following
commands:

```sh
# Generate the virtual environment
python3 -m venv .venv

# Activate the virtual environment
source .venv/bin/activate

# Install the requirements
pip install \
    --requirement requirements.txt \
    --requirement requirements-all.txt
```

Start the dependencies:

``` sh
docker compose up
```

Start the application:

```sh
# Switch to the `src` directory
cd src

# Start the application
uvicorn --reload --port 8080 main:app
```

Access the Core engine Backend documentation at <http://localhost:8080/docs>.

### Run the tests with Python

For each module a test file is available to check the correct behavior of the
code. The tests are run using the `pytest` library with code coverage check. To
run the tests, use the following command inside the `src` folder:

```sh
pytest --cov-report term:skip-covered --cov-report term-missing --cov=. -s --cov-config=.coveragerc
```

### Start the service locally with minikube and the Docker image hosted on GitHub

Start the Core engine Backend with the following commands. This will start the
Core engine with the official Docker images that are hosted on GitHub.

In the `backend` directory, start the Core engine Backend with the following
commands:

```sh
# Start MinIO
kubectl apply \
    -f kubernetes/minio.pvc.yml \
    -f kubernetes/minio.config-map.yml \
    -f kubernetes/minio.stateful.yml \
    -f kubernetes/minio.service.yml

# Start PostgreSQL
kubectl apply \
    -f kubernetes/postgres.pvc.yml \
    -f kubernetes/postgres.config-map.yml \
    -f kubernetes/postgres.stateful.yml \
    -f kubernetes/postgres.service.yml

# Start the core-engine
kubectl apply \
    -f kubernetes/core-engine.config-map.yml \
    -f kubernetes/core-engine.stateful.yml \
    -f kubernetes/core-engine.service.yml
```

Create a tunnel to access the Kubernetes cluster from the local machine. The
terminal in which the tunnel is created must stay open:

```sh
# Open a tunnel to the Kubernetes cluster
minikube tunnel --bind-address 127.0.0.1
```

Access the Core engine Backend documentation on <http://localhost:8080/docs>.

### Start the service locally with minikube and a local Docker image

**Note**: The Core engine Backend StatefulSet (`core-engine.stateful.yml` file)
must be deleted and recreated every time a new Docker image is created.

In the `backend` directory, build the Docker image with the following commands:

```sh
# Access the Minikube's Docker environment
eval $(minikube docker-env)

# Build the Docker image
docker build -t ghcr.io/swiss-ai-center/core-engine:latest .

# Exit the Minikube's Docker environment
eval $(minikube docker-env -u)

# Edit the `kubernetes/core-engine.stateful.yml` file to use the local image by uncommented the line `imagePullPolicy`
#
# From
#
#        # imagePullPolicy: Never
#
# To
#
#        imagePullPolicy: Never
```

In the `backend` directory, start the Core engine Backend with the following
commands:

```sh
# Start MinIO
kubectl apply \
    -f kubernetes/minio.pvc.yml \
    -f kubernetes/minio.config-map.yml \
    -f kubernetes/minio.stateful.yml \
    -f kubernetes/minio.service.yml

# Start PostgreSQL
kubectl apply \
    -f kubernetes/postgres.pvc.yml \
    -f kubernetes/postgres.config-map.yml \
    -f kubernetes/postgres.stateful.yml \
    -f kubernetes/postgres.service.yml

# Start the core-engine
kubectl apply \
    -f kubernetes/core-engine.config-map.yml \
    -f kubernetes/core-engine.stateful.yml \
    -f kubernetes/core-engine.service.yml
```

Create a tunnel to access the Kubernetes cluster from the local machine. The
terminal in which the tunnel is created must stay open:

```sh
# Open a tunnel to the Kubernetes cluster
minikube tunnel --bind-address 127.0.0.1
```

Access the Core engine Backend documentation on <http://localhost:8080/docs>.

## Frontend

The Frontend is built using React and TypeScript.

### Environment variables

All environment variables are described in the
[`.env`](https://github.com/swiss-ai-center/core-engine/blob/main/frontend/.env)
file.

The environment variables can be overwritten during the CI/CD pipeline described
in the
[`frontend.yml`](https://github.com/swiss-ai-center/core-engine/blob/main/.github/workflows/frontend.yml)
GitHub workflow file.

### Start the service locally with Node

In the `fronted` directory, start the Frontend with the following commands.

```sh
# Install the dependencies
npm ci --legacy-peer-deps

# Optional: Edit the environment variables to change the Core engine URL
vim .env

# Start the Core engine Frontend
npm run start
```

A browser should open on <http://localhost:3000> with the frontend running and
querying the Core engine backend.

### Build the application

In the `frontend` directory, build the Core engine Frontend with the following
commands.

```sh
# Install the dependencies
npm ci --legacy-peer-deps

# Build the Core engine Frontend
npm run build
```

The output of the build is in the `build` directory.

Once a React application is built, the environment variables cannot be changed.

### Build and run the Docker image

In order to build the Docker image, the application must be
[built](#build-the-application) beforehand. Then, the Docker image can be built
with the following commands.

```sh
# Build the Docker image with a tag
docker build -t swiss-ai-center/core-engine-frontend .

# Run the Docker image
docker run -p 8181:80 swiss-ai-center/core-engine-frontend
```

The Core engine Frontend is available on <http://localhost:8181>.

> **Q**: _Why don't we build the React application within the Docker image?_
>
> **A**: This setup allows us to speed up the build process of the Docker image: it does not need to download and install all dependencies every time the `package.json` file is updated. In a CI/CD set up, the `node_modules` can be cached in the `build` stage and the output can be passed to the `publish` stage.

### Start the service locally with minikube and the Docker image hosted on GitHub

Start the Core engine Frontend with the following commands. This will start the
Core engine Frontend with the official Docker images that are hosted on GitHub.

In the `frontend` directory, start the Core engine Frontend with the following
commands.

```sh
# Start the Core engine Frontend
kubectl apply \
    -f kubernetes/frontend.stateful.yml \
    -f kubernetes/frontend.service.yml
```

Create a tunnel to access the Kubernetes cluster from the local machine. The
terminal in which the tunnel is created must stay open.

```sh
# Open a tunnel to the Kubernetes cluster
minikube tunnel --bind-address 127.0.0.1
```

Access the Core engine Frontend on <http://localhost:8686>.

### Start the service locally with minikube and a local Docker image

**Note**: The service StatefulSet (`frontend.stateful.yml` file) must be deleted
and recreated every time a new Docker image is created.

Start the service with the following commands. This will start the service with
the a local Docker image for the service.

In the `frontend` directory, build the Docker image with the following commands.

```sh
# Install Node dependencies
npm ci --legacy-peer-deps

# Optional: Edit the environment variables to change the Core engine URL
vim .env

# Build the Core engine Frontend
npm run build

# Access the Minikube's Docker environment
eval $(minikube docker-env)

# Build the Docker image
docker build -t ghcr.io/swiss-ai-center/core-engine-frontend:latest .

# Exit the Minikube's Docker environment
eval $(minikube docker-env -u)

# Edit the `kubernetes/frontend.stateful.yml` file to use the local image by uncommented the line `imagePullPolicy`
#
# From
#
#        # imagePullPolicy: Never
#
# To
#
#        imagePullPolicy: Never
```

In the `frontend` directory, start the service with the following commands.

```sh
# Start the Core engine Frontend
kubectl apply \
    -f kubernetes/frontend.config-map.yml \
    -f kubernetes/frontend.stateful.yml \
    -f kubernetes/frontend.service.yml
```

Create a tunnel to access the Kubernetes cluster from the local machine. The
terminal in which the tunnel is created must stay open.

```sh
# Open a tunnel to the Kubernetes cluster
minikube tunnel --bind-address 127.0.0.1
```

Access the Core engine Frontend on <http://localhost:8686>.
